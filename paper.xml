<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/css" href="resources/css/paper.css"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0">
	<info>
		<title><emphasis role="bold">Documents from XQuery annotations</emphasis></title>
		<author>
			<personname>Andy Bunce</personname>
			<email>bunce.andy@gmail.com</email>
			<uri><link xmlns:xlink="http://www.w3.org/1999/xlink"
					xlink:href="https://github.com/apb2006">https://github.com/apb2006</link></uri>
			<personblurb>
				<para><?oxy-placeholder content="Details about you"?></para>
			</personblurb>
			<affiliation>
				<jobtitle>Director</jobtitle>
				<orgname>Quodatum Ltd</orgname>
			</affiliation>
		</author>
		<keywordset>
			<keyword>xquery</keyword>
			<keyword>documentation</keyword>
			<keyword>xqdoc</keyword>
			<keyword>annotation</keyword>
			<keyword>restxq</keyword>
		</keywordset>
		<abstract>
			<para>The paper describes an implementation of an xqDoc.org documentation generator. A focus of
				this implementation is XQuery annotation support. In 2014 the xqDoc schema was
				updated to include markup to capture XQuery annotations, however existing renderers
				have often not been updated to make use of this. A major driver for annotation
				support is documenting XQuery web applications built using the RESTXQ standard.
				RESTXQ defines a standard set of XQuery annotations that can be used to define
				RESTful Web Services from XQuery. Annotations are also being used to define
				frameworks for unit testing, user permissioning and web socket interfaces.
				Annotations are code markup that the runtime environment may choose to use to
				wire-in additional external functionality to XQuery applications. The xqdoc
				implementation is open source. It is largely written in XQuery and runs with recent
				versions of BaseX. It generates static, stand alone HTML5 and XML and JSON output. </para>
			<para>The included XQuery library modules can also be used to assist in the generation
				other related documentation artefacts. In the case of RESTXQ these could be the
				generation of openAPI(swagger) and WADL documents.</para>
		</abstract>
	</info>
	<section>
		<title>Introduction</title>
		<para>Making sense of a XQuery code base can be hard, even if you have written it yourself. It can
			be difficult to see how the parts fit together. This paper describes an attempt to build
			a documentation tool to help with that process with the particular goal of incorporating
			information from XQuery annotations. The paper looks at the history of annotations and
			the history of XQuery documentation tools </para>
	</section>
	<section>
		<title>Annotations</title>
		<para><?oxy-placeholder content="You can use not only paragraphs, but also programlistings, examples, lists, tables, etc."?></para>
		<section>
			<title>What are annotations?</title>
			<para> Wikipedia defines an <emphasis role="bold">annotation</emphasis> as "a metadatum
				(e.g. a post, explanation, <emphasis>markup</emphasis>) attached to location or
				other data." Their use in main-stream software engineering  began in 2004 when Java
				5 introduced them via JSR 175.</para>
			<para>Annotations in XQuery were introduced in 2014 starting with XQuery 3.0. The syntax
				is a "%" followed by a EQName and an optional set of values. The specification
				simply states: <quote>XQuery uses annotations to declare properties associated with
					functions (inline or declared in the prolog) and variables. </quote></para>
		</section>
		<section>
			<title>Use of annotations in XQuery</title>
			<para>The following sections show some applications of XQuery annotations, often they
				mirror similar usage in Java frameworks.</para>
			<section>
				<title>Built-in annotations</title>
				<para>The XQuery 3.1 standard defines only two annotations:<code>%private</code>
					<code>%public</code>.  XQuery 3.0 Update only one <code>%updating</code>. It
					also states:</para>
				<para><quote>Implementations may define further annotations, whose behaviour is
						implementation-defined. For instance, if the <code>eg</code> prefix is bound
						to a namespace associated with a particular implementation, it could define
						an annotation like <code>eg:sequential</code>. If the namespace URI of an
						annotation is not recognized by the implementation, then the annotation is
						ignored. Implementations may also provide a way for users to define their
						own annotations.</quote></para>
			</section>
			<section>
				<title>RestXQ</title>
				<para>At XML Prague in 2012 Adam Retter presented. see
						<citebiblioid>RESTXQ</citebiblioid> . It is based on the popular Java
					standard  for RESTful Web Services JAX-RS. It has since been implemented by many
					XQuery products as it provides a straight forward way to wire-up XQuery code to
					a web interface. </para>
				<para>A simple RESTXQ
					example<programlisting>module namespace page = 'http://basex.org/examples/web-page';
 
declare %rest:path("hello/{$who}") %rest:GET function page:hello($who) {
  &lt;response>
    &lt;title>Hello { $who }!&lt;/title>
  &lt;/response>
};  </programlisting></para>
				<para>Here the <code>%rest:path</code> annotation specifies a url and the
						<code>rest:GET</code> specifies an HTTP method. In a suitable Web server
					environment a request for "/hello/fred" will be wired up to invoke the
						<code>page:hello</code> function with the argument "fred". The result of the
					function will be returned by web server.</para>
			</section>
			<section>
				<title>Unit testing</title>
				<para>Unit testing is another popular domain for annotations. In the Java world
					JUnit has long made use of annotations. In XQuery <itemizedlist>
						<listitem>
							<para>Marklogic has <link xmlns:xlink="http://www.w3.org/1999/xlink"
									xlink:href="https://github.com/robwhitby/xray"
								>XRAY</link></para>
						</listitem>
					</itemizedlist></para>
			</section>
			<section>
				<title>Others</title>
				<para>The BaseX product has recently extended its list of built-in annotation
					handlers with<itemizedlist>
						<listitem>
							<para><code>%ws</code> To define access to <link
									xmlns:xlink="http://www.w3.org/1999/xlink"
									xlink:href="http://docs.basex.org/wiki/WebSockets#Annotations"
									>Web sockets</link></para>
						</listitem>
						<listitem>
							<para><code>%perm</code> To define a web application <link
									xmlns:xlink="http://www.w3.org/1999/xlink"
									xlink:href="http://docs.basex.org/wiki/Permissions">permission
									layer</link></para>
						</listitem>
					</itemizedlist></para>
				<para>The eXist-db product uses annotations in its html <link
						xmlns:xlink="http://www.w3.org/1999/xlink"
						xlink:href="https://exist-db.org/exist/apps/demo/examples/templating/templates.html"
						>templating</link> feature and the MarkLogic product uses annotations for
						<link xmlns:xlink="http://www.w3.org/1999/xlink"
						xlink:href="https://docs.marklogic.com/guide/xquery/enhanced#id_94002"
						>transaction control</link> .</para>
			</section>
		</section>
	</section>
	<section>
		<title>XQuery documentation</title>
		<para>The following sections describe XQuery documentation formats and tools.</para>
		<section>
			<title>The xqDoc format</title>
			<para>In 2002, Darin McBeath realised the need for a tool for generating documentation
				from XQuery sources and created xqDoc <biblioref/>. This defines an XML schema (
				namespace http://www.xqdoc.org/1.0) for recording information about XQuery modules
				and a reference JAVA implementation. To get full value from
					<productname>xqDoc</productname> the source should contain comments formatted
				according to certain conventions in a similar fashion to Javadoc comments. See
				example
				below<programlisting>(:~
: The controller for constructing the xqDoc HTML information for
: the specified library module. The following information for
: each library module will be generated.
: &lt;ul>
: &lt;li> Module introductory information&lt;/li>
: &lt;li> Global variables declared in this module&lt;/li>
: &lt;li> Modules imported by this module&lt;/li>
: &lt;li> Summary information for each function defined in the module&lt;/li>
: &lt;li> Detailed information for each function defined in the module&lt;/li>
: &lt;/ul>
:
: @param $uri the URI for the library module
: @param $local indicates whether to build static HTML link for offline
: viewing or dynamic links for real-time viewing.
: @return XHTML.
:)
define function print-module($uri as xs:string, $local as xs:boolean) as element()* 
</programlisting></para>
			<section>
				<title>Working with xqDoc documents</title>
				<para>Tips:</para>
				<para>Function names may be referenced in XQuery in a number of different
					styles</para>
				<para>
					<itemizedlist>
						<listitem>
							<para><code>abc:foo(42)</code> or
								<code>anotherprefix:foo(42)</code></para>
						</listitem>
						<listitem>
							<para><code>foo(42)</code> (: with a default function namespace
								definition :)</para>
						</listitem>
						<listitem>
							<para><code>Q{http://nowhere.com/funs}foo(42)</code></para>
						</listitem>
					</itemizedlist>
				</para>
				<para>Most xqDoc implements return these as coded rather than normalising them to a
					standard form. This can make finding cross-references  more complex</para>
				<para>Static context: Some implementations allow their library modules to be used
					without explicit import module statements. </para>
				<para>If these imports are not listed in the generated
						<productname>xqdoc</productname> it can be difficult to resolve some names.
					This suggests an xqdoc generator needs information about the target platform
					both for it's grammar and  it's static context.</para>
			</section>
		</section>
		<section>
			<title>Updates</title>
			<section>
				<para><productname>xqDoc</productname> was initially written to target XQuery 1.0.
					In 2014 the schema was extended to capture XQuery annotation information defined
					in XQuery 3.0. The figure below highlights the addition: </para>
			</section>
		</section>
		<section>
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="xqdoc-schema.png" width="100%" scalefit="1"/>
					</imageobject>
				</inlinemediaobject></para>
		</section>
		<section>
			<title>Components</title>
			<para>Implementations of <productname>xqDoc</productname>  have three main components:<orderedlist>
					<listitem>
						<para>A component to parse the XQuery source code and generate the
							corresponding <productname>xqDoc</productname> XML elements for
							functions and variable etc.</para>
					</listitem>
					<listitem>
						<para>A component to parse xqdoc style comments <code>(:~ … :)</code> into
							the corresponding xqDoc </para>
					</listitem>
					<listitem>
						<para>Optionally a means to render the resulting XML into formats for
							reading such as HTML. Typically using XSLT.</para>
					</listitem>
				</orderedlist></para>
			<section>
				<title>xqdoc.org</title>
				<para>Is written in Java and uses ANTLR 2.7 for the parsing. </para>
			</section>
			<section>
				<title>ExistDb</title>
				<para>Providesthe docs module</para>
			</section>
			<section>
				<title>BaseX</title>
				<para><?oxy-placeholder content="You can use not only paragraphs, but also programlistings, examples, lists, tables, etc."?></para>
			</section>
		</section>
		<section>
			<title>Parsers</title>
			<para>Typically the code to implement parser is generated using a tool rather than hand
				written. Tools that   have been used for this task are ANTLR and REX</para>
		</section>
	</section>
	<section>
		<title>Introducing xqDocA</title>
		<para>Motivation..</para>
		<section>
			<title>Overview</title>
			<para>Given a list of the files to process...</para>
			<para> It creates an XQuery map that holds information about the source location of each
				file along with a created XML parse tree and xqdoc. This map is is referred to as
				the <emphasis>model</emphasis>. Another map holds configuration options to apply to
				the run. This includes a list of "renderers" to run against the
					<emphasis>model</emphasis>.</para>
			<para>The model</para>
			<para><inlinemediaobject>
					<imageobject>
						<imagedata fileref="images/model.svg"/>
					</imageobject>
				</inlinemediaobject></para>
			<para>A renderer creates a single output file. There are currently two kinds of
				renderers. <orderedlist>
					<listitem>
						<para><emphasis>global</emphasis>: this generates an output that is project
							wide, such as an index.</para>
					</listitem>
					<listitem>
						<para><emphasis>module</emphasis>this generates an output for each XQuery
							source file, such as a direct rendering of a xqDoc file.</para>
					</listitem>
				</orderedlist></para>
			<section>
				<title>Renderers</title>
				<para>Are implemented as a map with the following keys:<table>
						<caption>Renderer properties</caption>
						<col width="50%"/>
						<col/>
						<col/>
						<thead>
							<tr>
								<th>Key</th>
								<th>Type</th>
								<th>Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Name</td>
								<td/>
								<td/>
							</tr>
							<tr>
								<td>description</td>
								<td/>
								<td/>
							</tr>
							<tr>
								<td>type</td>
								<td/>
								<td/>
							</tr>
							<tr>
								<td>uri</td>
								<td/>
								<td/>
							</tr>
							<tr>
								<td>function</td>
								<td/>
								<td/>
							</tr>
						</tbody>
					</table></para>
				<para>The listing below shows some example
					renderers<programlisting>map {
  "output": "html5",
  "name": "index",
  "uri": "index.html",
  "function": Q{quodatum:build.xqdoc-html}index-html2#2,
  "type": Q{https://github.com/Quodatum/xqdoca}global,
  "description": "Index of sources"
}
map {
  "output": "html5",
  "name": "import",
  "uri": "imports.html",
  "function": Q{quodatum:build.xqdoc-html}imports#2,
  "type": Q{https://github.com/Quodatum/xqdoca}global,
  "description": "Summary of import usage"
}

map {
  "output": "json",
  "name": "swagger1",
  "uri": "swagger.json",
  "function": Q{quodatum:xqdoca.generator.swagger}swagger#2,
  "type": Q{https://github.com/Quodatum/xqdoca}global,
  "description": "Swagger file (JSON format) from restxq annotations."
}

map {
  "output": "xml",
  "name": "xqparse",
  "uri": "xqparse.xml",
  "function": Q{quodatum:xqdoca.mod-html}xqparse#3,
  "type": Q{https://github.com/Quodatum/xqdoca}module,
  "description": "xqparse file for the source module"
}</programlisting></para>
			</section>
		</section>
		<section>
			<title>Implementation</title>
			<para>It uses XQuery 3.1 The parsing uses REX</para>
			<para><inlinemediaobject>
					<imageobject>
						<imagedata fileref="xqDocA.png" width="100%" scalefit="1"/>
					</imageobject>
				</inlinemediaobject></para>
			<para/>
		</section>
		<section>
			<title>Customisation</title>
			<para>With any report generator it is likely that customization will be required. To
				facilitate this new <productname>xqdoca</productname> outputs can be added to the
				system without modifications to the driver code. A plug-in system is provided using
				the dynamic loading of code modules.</para>
			<para>This is done using custom annotations within the <productname>xqdoca</productname> code
				base. Functions that generate <productname>xqdoca</productname> output must have
				annotations in the <productname>xqdoca</productname> namespace indicating their
				role. At runtime a designated directory is scanned for XQuery modules and functions
				containing the appropriate annotations can be invoked. </para>
			<para>This requires two features to be provided by the XQuery environment:<orderedlist>
					<listitem>
						<para>Dynamic module loading. This is provided in the XQuery 3.1
							specification though <code>fn:load-xquery-module</code>. Currently this
							is not widely supported however many implementation have custom variants
							that provide equivalent functionality.</para>
					</listitem>
					<listitem>
						<para>Annotation introspection. That is the ability at runtime to determine
							what annotations were attached to a function. This is not a feature with
							any standardization but again is widely supported via vendor libraries.
							See <link xmlns:xlink="http://www.w3.org/1999/xlink"
								xlink:href="https://www.saxonica.com/html/documentation/functions/saxon/function-annotations.html"
								>Saxon</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink"
								xlink:href="https://docs.marklogic.com/sc:annotations"
								>MarkLogic</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink"
								xlink:href="http://docs.basex.org/wiki/Inspection_Module#inspect:function-annotations"
								>BaseX</link>, <link xmlns:xlink="http://www.w3.org/1999/xlink"
								xlink:href="https://exist-db.org/exist/apps/fundocs/view.html?uri=http://exist-db.org/xquery/inspection"
								>eXist-db</link></para>
					</listitem>
				</orderedlist></para>
		</section>
	</section>
	
	<section>
		<title>Conclusion</title>
		<para>@TODO</para>

	</section>

	<bibliography xml:id="references">
		<bibliomixed><abbrev>XQUERY31SPEC</abbrev>
			<author>
				<personname><surname>Speigel</surname>
					<firstname>Josh</firstname></personname>
			</author>: <title>XQuery 3.1: An XML Query Language</title>. <date>21 3 2017</date>,
				<orgname>W3C</orgname>
			<bibliomisc><link xl:href="https://www.w3.org/TR/2017/REC-xquery-31-20170321/"
				/></bibliomisc></bibliomixed>
		<bibliomixed><abbrev>RESTXQ</abbrev>
			<author>
				<personname><surname>Retter</surname>
					<firstname>Adam</firstname></personname>
			</author>: <title>RESTXQ 1.0: RESTful Annotations for XQuery</title>. <date>21 March
				2016</date>, <orgname><link xmlns:xlink="http://www.w3.org/1999/xlink"
					xlink:href="http://exquery.org/">http://exquery.org/</link></orgname>
			<bibliomisc><link
					xl:href="http://exquery.github.io/exquery/exquery-restxq-specification/restxq-1.0-specification.html"
				/></bibliomisc></bibliomixed>
		<bibliomixed><abbrev> JAX-RS API</abbrev>
			<author>
				<personname><surname>Bucek</surname>
					<firstname>Pavel</firstname></personname>
			</author>: <title>JSR 370: JavaTM API for RESTful Web Services (JAX-RS 2.1)
				Specification</title>. <date>22 Aug 2017</date>, <orgname>Java Community Process
				(JCP)</orgname>
			<bibliomisc><link><link xmlns:xlink="http://www.w3.org/1999/xlink"
						xlink:href="https://jcp.org/en/jsr/detail?id=370"
						>https://jcp.org/en/jsr/detail?id=370</link></link></bibliomisc></bibliomixed>
		<bibliomixed><abbrev>XQDOC</abbrev>
			<author>
				<personname><surname>McBeath</surname>
					<firstname>Darrin</firstname></personname>
			</author>: <title>xqDoc website</title>. <date>13 Jan 2014</date>, <orgname><link
					xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://xqdoc.org"
					>http://xqdoc.org</link></orgname>
			<bibliomisc><link><link xmlns:xlink="http://www.w3.org/1999/xlink"
						xlink:href="http://xqdoc.org/index.html"
					>http://xqdoc.org/index.html</link></link></bibliomisc></bibliomixed>
		<bibliomixed><abbrev>XPARSE</abbrev>
			<author>
				<personname><surname>Lumley</surname>
					<firstname>John</firstname></personname>
			</author>: <title>XParse Module</title>. <date>8 Dec 2014</date>, <orgname><link
					xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://expath.org/"
					>http://expath.org/</link></orgname>
			<bibliomisc><link><link xmlns:xlink="http://www.w3.org/1999/xlink"
						xlink:href="https://lists.w3.org/Archives/Public/public-expath/2015Feb/att-0003/xparse.html"
						>https://lists.w3.org/Archives/Public/public-expath/2015Feb/att-0003/xparse.html</link></link></bibliomisc></bibliomixed>
	</bibliography>

</article>
